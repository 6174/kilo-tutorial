# A text viewer

## A line viewer

Let's create a data type for storing a row of text in our editor.

{{single-line-erow}}

`erow` stands for "editor row", and stores a line of text as a pointer to the
dynamically-allocated character data and a length. The `typedef` lets us refer
to the type as `erow` instead of `struct erow`. We'll be using the `erow`
struct in a lot of our code, so it helps to have a shorter name for it.

We add an `erow` value to the editor global state, as well as a `numrows`
variable. For now, the editor will only display a single line of text, and so
`numrows` can be either `0` or `1`. We initialize it to `0` in `initEditor()`.

Let's fill that `erow` with some text now. We won't worry about reading from a
file just yet. Instead, we'll put a "Hello, world" string into it.

{{single-line-hardcoded}}

`ssize_t` comes from `<sys/types.h>`.

`editorOpen()` will eventually be for opening and reading a file from disk, so
we put it in a new `/*** file i/o ***/` section. To load our "Hello, world"
message into the editor's `erow` struct, we set the `size` field to the length
of our message, `malloc()` the necessary memory, and `memcpy()` the message to
the `chars` field which points to the memory we allocated. Finally, we set the
`E.numrows` variable to `1`, to indicate that the `erow` now contains a line
that should be displayed.

Let's display it then.

{{single-line-render}}

We wrap our previous row-drawing code in an `if` statement that checks whether
we are currently drawing a row that is part of the text buffer, or a row that
comes after the end of the text buffer.

To draw a row that's part of the text buffer, we simply write out the `chars`
field of the `erow`. But first, we take care to truncate the rendered line if
it would go past the end of the screen.

Next, let's allow the user to open an actual file. We'll read and display the
first line of the file.

{{single-line-file}}

`FILE`, `fopen()`, and `getline()` come from `<stdio.h>`.

The core of `editorOpen()` is the same, we just get the `line` and `linelen`
values from `getline()` now, instead of hard-coded values.

Of course, `editorOpen()` now takes a filename and opens the file for reading
using `fopen()`. We allow the user to choose a file to open by checking if they
passed a filename as a command line argument. If they did, we call
`editorOpen()` and pass it the filename. If they ran `./kilo` with no
arguments, `editorOpen()` will not be called and they'll start with a blank
file.

`getline()` is useful for reading lines from a file when we don't know how much
memory to allocate for each line. `getline()` takes care of memory management
for you. First, we pass it a NULL `line` pointer and a `linecap` (line
capacity) of `0`. So it will allocate memory for the next line it reads, and
set `line` to point to the memory, and set `linecap` to let you know how much
memory it allocated. Its return value is the actual length of the line it read,
or `-1` if it hits the end of file. Later, when we have `editorOpen()` read
multiple lines of a file, we will be able to feed the new `line` and `linecap`
values back into `getline()` over and over, and it will try and reuse the
memory that `line` points to as long as the `linecap` is enough to fit the next
line it reads. For now, we just copy the one line it reads into `E.row.chars`,
and `free()` the `line` that `getline()` allocated.

We also strip off the newline or carriage return at the end of the line before
copying it into our `erow`. We know each `erow` represents one line of text, so
there's no use storing a newline character at the end of each one. It would
actually get in the way and be annoying later when we started implementing
various operations on `erow`s.

If your compiler complains about `getline()`, you may need to define a [feature
test macro](https://www.gnu.org/software/libc/manual/html_node/Feature-Test-Macros.html).
Even if it compiles fine on your machine without them, let's add them to make
our code more portable.

{{getline-defines}}

We add them above our includes, because the header files use the macros to
decide what features to expose when we include them.

Now let's fix a quick bug. We want the welcome message to only display when the
user starts the program with no arguments, and not when they open a file, as
the welcome message could get in the way of displaying the file in that case.

{{hide-welcome-message}}

There, now the welcome message only displays if the text buffer is completely
empty.

## Multiple lines

To store multiple lines, let's make `E.row` an array of `erow` structs. It will
be a dynamically-allocated array, so we'll make it a pointer to `erow`, and
initialize the pointer to `NULL`.

{{multiple-lines-struct}}

Next, let's move the code in `editorOpen()` that initializes `E.row` to a new
function called `editorAppendRow()`. We'll also put it under a new section,
`/*** row operations ***/`.

{{append-row}}

We want `editorAppendRow()` to allocate space for a new `erow`, and then copy
the given string to a new `erow` at the end of the `E.row` array. Let's do that
now.

{{fix-append-row}}

We have to tell `realloc()` how many bytes we want to allocate, so we multiply
the number of bytes each `erow` takes (`sizeof(erow)`) and multiply that by the
number of rows we want. Then we set `at` to the index of the new row we want to
initialize, and replace each occurrence of `E.row` with `E.row[at]`. We also
make sure to use the arguments names `s` and `len` instead of `line` and
`linelen`. Lastly, we change `E.numrows = 1;` to `E.numrows++;`.

Next, let's update `editorDrawRows()` to use `E.row[y]` instead of `E.row`,
when printing out the current line.

{{render-multiple-lines}}

At this point the code should compile, but still only reads a single line from
the file. Let's add a `while` loop to `editorOpen()` to read an entire file
into `E.row`.

{{read-multiple-lines}}

The `while` loop works because `getline()` returns `-1` when it gets to the end
of the file and there are no more lines to read.

Now you should see your screen fill up with lines of text when you run
`./kilo kilo.c`, for example.

## Vertical scrolling

Next we want to enable the user to scroll through the whole file, instead of
just being able to see the top few lines of the file. Let's add a `rowoff` (row
offset) variable to the global editor state, which will keep track of what row
of the file the user is currently scrolled to.

{{rowoff}}

We initialize it to `0`, which means we'll be scrolled to the top of the file
by default.

Now let's have `editorDrawRows()` display the correct range of lines of the
file according to the value of `rowoff`.

{{filerow}}

To get the row of the file that we want to display at each `y` position, we add
`E.rowoff` to the `y` position. So we define a new variable `filerow` that
contains that value, and use that as the index into `E.row`.

Now where do we set the value of `E.rowoff`? Our strategy will be to check if
the cursor has moved outside of the visible window, and if so, adjust
`E.rowoff` so that the cursor is just inside the visible window. We'll put this
logic in a function called `editorScroll()`, and call it right before we
refresh the screen.

{{editor-scroll}}

The first `if` statement checks if the cursor is above the visible window into
the file, and if so, scrolls up to where the cursor is. The second `if`
statement checks if the cursor is past the bottom of the visible window, and
contains slightly more complicated arithmetic because `E.rowoff` refers to
what's at the top of the screen, and we have to use `E.screenrows` to talk
about what's at the bottom of the screen.

Now let's finally allow the cursor to advance past the bottom of the screen
(but not past the bottom of the file).

{{enable-vertical-scroll}}

You should be able to scroll through the entire file now, when you run `./kilo
kilo.c`. If you try to scroll back up, you may notice the cursor isn't being
positioned properly. We need to position it at `E.cy - E.rowoff` instead of
`E.cy`. Let's fix that.

{{fix-cursor-scrolling}}

## Horizontal scrolling

Now let's work on horizontal scrolling. We'll implement it in just about the
same way we implemented vertical scrolling. Start by adding a `coloff` (column
offset) variable to the global editor state.

{{coloff}}

Now to display each row at the column offset, we'll use `E.coloff` as an index
into `E.row[filerow].chars`, and also update the `len` by subtracting the
chars to the left of the offset from `E.row[filerow].size`.

{{render-coloff}}

Note that when subtracting `E.coloff` from the length, `len` can now be a
negative number. If it is, we set it to `0` so that nothing is displayed on
that line.

Now let's update `editorScroll()` to handle horizontal scrolling.

{{editor-scroll-horizontal}}

As you can see, it is exactly parallel to the vertical scrolling code. We just
replace `E.cy` with `E.cx`, `E.rowoff` with `E.coloff`, and `E.screenrows` with
`E.screencols`.

Now let's allow the user to scroll past the right edge of the screen.

{{enable-horizontal-scroll}}

You should be able to confirm that horizontal scrolling now works.

Next, let's fix the cursor positioning, just like we did with vertical
scrolling.

{{fix-cursor-scrolling-horizontal}}

## Limit scrolling to the right

Let's not allow the user to scroll past the end of the current line.

{{scroll-limits}}

Since `E.cy` is allowed to be one past the last line of the file, we use the
ternary operator to check if the cursor is on an actual line. If it is, then
the `row` variable will point to the `erow` that the cursor is on, and we'll
check whether `E.cx` is to the left of the end of that line before we allow the
cursor to move to the right.

## Snap cursor to end of line

The user is still able to move the cursor past the end of a line, however. They
can do it by moving the cursor to the end of a long line, then moving it down
to the next line, which is shorter. The `E.cx` value won't change, and the
cursor will be off to the right of the end of the line it's now on.

Let's add some code to `editorMoveCursor()` that corrects `E.cx` if it ends up
past the end of the line it's on.

{{snap-cursor}}

We have to set `row` again, since `E.cy` could point to a different line than
it did before. We then set `E.cx` to the end of that line if `E.cx` is to the
right of the end of that line. Also note that we consider a `NULL` line to be
of length `0`, which works for our purposes here.

## Moving left at the start of a line

{{moving-left}}

## Moving right at the end of a line

{{moving-right}}

## Rendering tabs

{{render-chars}}

{{editor-update-row}}

{{render-render}}

{{render-tabs}}

## Tabs and the cursor

{{rx}}

{{cx-to-rx}}

{{render-rx}}

{{rx-tabs}}

## Page Up and Page Down

{{detect-page-up-down}}

{{page-up-down}}

## Home and End keys

{{detect-home-end-keys}}

{{home-end-keys}}

## Status bar

{{status-bar-make-room}}

{{blank-status-bar}}

{{filename}}

{{status-bar-left}}

{{status-bar-right}}

## Status message

{{status-message-data}}

{{set-status-message}}

{{message-bar-make-room}}

{{render-message-bar}}

