# Search

## Basic search

Let's use `editorPrompt()` to implement a minimal search feature. When the user
types a search query and presses enter, we'll loop through all the rows of the
file, and if a row contains their query string, we'll move the cursor to the
matching substring.

{{basic-search}}

`strstr()` comes from `<string.h>`.

If they pressed escape to cancel the prompt input, then `editorPrompt()`
returns `NULL` and we abort the search in that case.

Otherwise, we loop through all the rows of the file. We use `strstr()` to check
if `query` is a substring of the current row. It returns `NULL` if there is no
match, otherwise it returns a pointer to the matching substring. To convert
that into an index that we can set `E.cx` to, we subtract the pointer to the
beginning of the row's `render` string from the `match` pointer. Lastly, we
set `E.rowoff` to the very bottom of the file, which will have the effect of
scrolling up at the next screen refresh so that the matching line will always
be at the very top of the screen.

There's one problem here. Did you notice what we just did wrong? We assigned a
`render` index to `E.cx`, but `E.cx` is an index into `chars`. If there are
tabs to the left of the match, the cursor is going to get positioned wrong. We
need to convert the `render` index into a `chars` index before assigning it to
`E.cx`. Let's create an `editorRowRxToCx()` function, which is sort of the
opposite of `editorRowCxToRx()`, but contains a lot of the same code.

{{rx-to-cx}}

To convert an `rx` into a `cx`, we do pretty much the same thing when
converting the other way: loop through the `chars` string, calculating the
current `rx` value (`cur_rx`) as we go. But instead of stopping when we hit a
particular `cx` value and returning `rx`, we want to stop when we hit the
given `rx` value and return `cx` at that point.

The `return` statement at the very end is just in case the caller provided an
`rx` that's out of range, which shouldn't happen. The `return` statement inside
the `for` loop should handle all `rx` values that are valid indexes into
`render`.

Now let's call `editorRowRxToCx()` in between calculating the matched index and
assigning it to `E.cx`.

{{call-rx-to-cx}}

Now let's map `Ctrl+F` to the `editorFind()` function, and add it to the help
message we set in `main()`.

{{basic-search-key}}

## Incremental search

Now, let's make our search feature fancy. We want to support incremental
search, meaning the file is searched after each keypress when the user is
typing in their search query. This gives the user immediate feedback about
their search.

To implement this, we're going to get `editorPrompt()` to take a callback
function as an argument. It will call this function after each keypress,
passing the current search query inputted by the user and the last key they
pressed.

{{editor-prompt-callback}}

The `if` statements allow the caller to pass `NULL` for the callback, in case
they don't want to use a callback. This is the case when we prompt the user
for a filename, so let's pass `NULL` to `editorPrompt()` when we do that. We'll
also pass `NULL` to `editorPrompt()` in `editorFind()` for now, to get the code
to compile.

{{null-callback}}

Now let's move the actual searching code from `editorFind()` into a function
called `editorFindCallback()`. Obviously this will be our callback function for
`editorPrompt()`.

{{incremental-search}}

Now the file is being searched after each keypress until the user hits enter or
escape. We've successfully implemented incremental search.

## Restore cursor position when escaping out of search

When the user presses escape to abort a search, we want the cursor to go back
to where it was when they started the search. To do that, we'll have to save
their cursor position and scroll position, and restore those values after the
search is cancelled.

{{restore-cursor}}

If `query` is `NULL`, that means they pressed escape, so in that case we
restore the values we saved.

## Search forward and backward

The last feature we'd like to add is allowing the user to advance to the next
or previous match in the file, using the arrow keys.

We'll implement this feature using two static variables in our callback.
`last_match` will contain the index of the row that the last match was on, or
`-1` if there was no match. And `find_next` will store the direction of the
search: `1` for searching forward, and `-1` for searching backward.

{{search-arrows-statics}}

As you can see, we always reset `last_match` to `-1` unless an arrow key was
pressed. So we'll only advance to the next or previous match when an arrow key
is pressed. You can also see that we always set `find_next` to `1` unless the
left or up arrow key was pressed. So we always search in the forward direction
unless the user specifically asks to search backwards from the last match.

If `key` is `\r` (enter) or `\x1b` (escape), that means `editorPrompt()` is
about to return, and so the search operation is over. So we reset `last_match`
and `find_next` to their initial values to get ready for the next search
operation.

Now that we have those variables all set up, let's use them in the search code.

{{search-arrows}}

`current` is the index of the current row we are searching. If there was a last
match, it starts on the line after (or before, if we're searching backwards),
otherwise it starts at the top of the file.

The `if ... else if` causes `current` to go from the end of the file back to
the beginning of the file, or vice versa, to allow a search to "wrap around"
the end of a file and continue from the top (or bottom).

When we find a match, we set `last_match` to `current`, so that if the user
presses the arrow keys, we'll start the next search from that point.

Finally, let's not forget to update the prompt text to let the user know they
can use the arrow keys.

{{search-arrows-help}}

