# Syntax highlighting

## Colorful digits

Let's start by just getting some color on the screen, as simply as possible.
We'll attempt to highlight numbers by coloring every digit in the text red.

{{syntax-digits}}

We can no longer just feed the substring of `render` that we want to print
right into `abAppend()`. We'll have to do it character-by-character from now
on. So we loop through the characters and use `isdigit()` on each one to test
if it is a digit character. If it is, then we precede it with the `<esc>[31m`
escape sequence and follow it by the `<esc>[39m` sequence.

We previously used the `m` command
([Select Graphic Rendition](http://vt100.net/docs/vt100-ug/chapter3.html#SGR))
to draw the status bar using inverted colors. Now we are using it to set the
color of the text displayed after it. The
[VT100 User Guide](http://vt100.net/docs/vt100-ug/chapter3.html) we've been
using doesn't document color, so let's turn to the Wikipedia article on
[ANSI escape codes](https://en.wikipedia.org/wiki/ANSI_escape_code). It
includes a large table containing all the different argument codes you can use
with the `m` command on various terminals. It also includes the ANSI color
table with the 8 foreground/background colors available.

The first table says we can set the text color using codes `30` to `37`, and
reset it to the default color using `39`. The color table says `0` is black,
`1` is red, and so on, up to `7` which is white. Putting these together, we can
set the text color to red using `31` as an argument to the `m` command. After
printing the digit, we use `39` as an argument to `m` to set the text color
back to normal.

## Refactor syntax highlighting

Now we know how to color text, but we're going to have to do a lot more work to
actually highlight entire strings, keywords, comments, and so on. We can't just
decide what color to use based on the class of each character, like we're doing
with digits currently. What we want to do is figure out the highlighting for
each row of text before we display it, and then rehighlight a line whenever it
gets changed. To do that, we need to store the highlighting of each line in an
array. Let's add an array to the `erow` struct named `hl`, which stands for
"highlight".

{{syntax-refactoring-hl}}

`hl` is an array of `unsigned char` values, meaning integers in the range of
`0` to `255`. Each value in the array will correspond with a character in
`render`, and will tell you whether that character is part of a string, or a
comment, or a number, and so on. Let's create an `enum` containing the possible
values in the `hl` array.

{{highlight-enum}}

For now, we'll focus on highlighting numbers only. So we want every character
that's part of a number to have a corresponding `HL_NUMBER` value in the `hl`
array, and we want every other value in `hl` to be `HL_NORMAL`.

Let's create a new `/*** syntax highlighting ***/` section, and create an
`editorUpdateSyntax()` function it. This function will go through the contents
of an `erow` and highlight it by setting each value in the `hl` array.

{{editor-update-syntax}}

First we `realloc()` the needed memory, since this might be a new row or the
row might be bigger than the last time we highlighted it. Notice that the size
of the `hl` array is the same as the `render` array, so we use `rsize` as the
amount of memory to allocate for `hl`.

Then we use `memset()` to set all characters to `HL_NORMAL` by default, before
looping through the characters and setting the digits to `HL_NUMBER`. (Don't
worry, we'll implement a better way of recognizing number soon enough, but
right now we are focusing on refactoring.)

Now let's actually call `editorUpdateSyntax()`.

{{call-update-syntax}}

`editorUpdateRow()` already has the job of updating the `render` array, so it
makes sense that that's where we want to update the `hl` array. So after
updating `render`, we call `editorUpdateSyntax()` at the end.

Next, let's make an `editorSyntaxToColor()` function that maps values in `hl`
to the actual ANSI color codes we want to draw them as.

{{editor-syntax-to-color}}

We return the ANSI code for "foreground red" for numbers, and "foreground
white" for anything else that might slip through. (We'll be handling
`HL_NORMAL` separately, so `editorSyntaxToColor()` doesn't need to handle it.)

Now let's finally draw the highlighted text to the screen!

{{render-hl}}

First we get a pointer, `hl`, to the slice of `hl` that corresponds to the
slice of `render` that we have in the `c` pointer. Then, for each character, if
it's an `HL_NORMAL` character, we use `<esc>[39m` to make sure we're using the
default text color before printing it. If it's not `HL_NORMAL`, we use
`snprintf()` to write the escape sequence into a buffer which we pass to
`abAppend()` before appending the actual character. Finally, after we're done
looping through all the characters and displaying them, we print a final
`<esc>[39m` escape sequence to make sure the text color is reset to default.

This works, but do we really have to write out an escape sequence before every
single character? In practice, most characters are going to be the same color
as the previous character, so most of the escape sequences are redundant. Let's
keep track of the current text color as we loop through the characters, and
only print out an escape sequence when the color changes.

{{current-color}}

`current_color` is `-1` when we want the default text color, otherwise it is
set to value that `editorSyntaxToColor()` last returned. When the color
changes, we print out the escape sequence for that color and set
`current_color` to the new color. When we go from highlighted text back to
`HL_NORMAL` text, we print out the `<esc>[39m` escape sequence and set
`current_color` to `-1`.

That concludes our refactoring of the syntax highlighting system.

## Colorful search results

Before we start highlighting numbers and strings and all that, let's use our
highlighting system to highlight search results. We'll start by adding
`HL_MATCH` to the `editorHighlight` enum, and map it to the color blue (`34`)
in `editorSyntaxToColor()`.

{{hl-match}}

Now all we have to do is `memset()` the matched substring to `HL_MATCH` in our
search code.

{{search-highlighting}}

`match - row->render` is the index into `render` of the match, so we use that
as our index into `hl`.

## Restore syntax highlighting after search

Currently, search results stay highlighted in blue even after the user is done
using the search feature. We want to restore `hl` to its previous value after
each search. To do that, we'll save the original contents of `hl` in a static
variable named `saved_hl` in `editorFindCallback()`, and restore `hl` to the
contents of `saved_hl` at the top of the callback.

{{restore-search-highlight}}

We use another static variable named `saved_hl_line` to know which line's `hl`
needs to be restored. `saved_hl` is a dynamically allocated array which points
to `NULL` when there is nothing to restore. If there is something to restore,
we `memcpy()` it to the saved line's `hl` and then deallocate `saved_hl` and
set it back to `NULL`.

Notice that the `malloc()`'d memory is guaranteed to be `free()`'d, because
when the user closes the search prompt by pressing enter or escape,
`editorPrompt()` calls our callback, giving a chance for `hl` to be restored
before `editorPrompt()` finally returns. Also notice that it's impossible for
`saved_hl` to get `malloc()`'d before its old value gets `free()`'d, because we
always `free()` it at the top of the function. And finally, notice that it's
impossible for the user to edit the file between saving and restoring the `hl`,
so we can safely use `saved_hl_line` as an index into `E.row`. It's important
to think about these things.

## Colorful numbers

Alright, let's start working on highlighting numbers properly. First, we'll
change our `for` loop in `editorUpdateSyntax()` to a `while` loop, to allow us
to consume multiple characters each iteration. (We'll only consume one
character at a time for numbers, but this will be useful for later.)

{{syntax-numbers-while}}

Now let's define an `is_separator()` function that takes a character and
returns true if it's considered a separator character.

{{is-separator}}

Right now, numbers are highlighted even if they're part of an identifier, such
as the `32` in `int32`. To fix that, we'll require that numbers are preceded by
a separator character, which includes whitespace or punctuation characters. We
also include the nul character (`'\0'`), because then we can count the nul byte
at the end of each line as a separator, which will make some of our code
simpler in the future.

Let's add a `prev_sep` variable to `editorUpdateSyntax()` that keeps track if
the previous character was a separator. Then let's use it to highlight numbers
properly.

{{prev-sep}}

We initialize `prev_sep` to `1` (meaning true) because we consider the
beginning of the line to be a separator. (Otherwise numbers at the very
beginning of the line wouldn't be highlighted.)

`prev_hl` is set to highlight type of the previous character, which we will use
a lot. For example, we now require the previous character to either be a
separator, or to be highlighted as part of a number when we decide whether to
highlight the current character as a number.

When we decide to highlight the current character a certain way (`HL_NUMBER` in
this case), we increment `i` to "consume" that character, set `prev_sep` to `0`
to indicate we are in the middle of highlighting something, and then `continue`
the loop. We will use this pattern for each thing that we highlight.

If we end up not highlighting the current character, then we'll end up at the
bottom of the `while` loop, where we set `prev_sep` according to whether the
current character is a separator, and we increment `i` to consume the
character. The `memset()` we did at the top of the function means that an
unhighlighted character will have a value of `HL_NORMAL` in `hl`.

Now let's support highlighting numbers with decimal points.

{{syntax-numbers-decimal-point}}

A `.` character that comes after a character that we just highlighted as a
number will now be considered part of the number.

## Detect filetype

Before we go on to highlight other

{{editor-syntax}}

{{hldb}}

{{e-syntax}}

{{show-filetype}}

{{update-syntax-filetype}}

{{select-syntax-highlight}}

{{call-select-syntax-highlight}}

{{filetype-save-as}}

## Colorful strings

{{hl-string}}

{{hl-string-flag}}

{{syntax-strings}}

{{syntax-string-escapes}}

## Colorful single-line comments

{{hl-comment}}

{{scs}}

{{syntax-comments}}

## Colorful keywords

{{hl-keywords}}

{{c-keywords}}

{{syntax-keywords}}

## Not so colorful non-printable characters

{{nonprintables}}

{{nonprintables-fix-color}}

## Colorful multiline comments

{{hl-multiline-comments}}

{{mcs-mce}}

{{mcs-mce-len}}

{{syntax-mlcomment}}

{{mlcomment-fix-slcomment-and-strings}}

{{idx-and-hloc}}

{{update-idx}}

{{propagate-comment}}

