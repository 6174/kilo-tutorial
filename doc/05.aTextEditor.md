# A text editor

## Insert ordinary characters

Let's begin by writing a function that inserts a single character into an
`erow`, at a given position.

{{row-insert-char}}

`memmove()` comes from `<string.h>`.

First we validate `at`, which is the index we want to insert the character
into. Notice that `at` is allowed to go one character past the end of the
string, in which case the character should be inserted at the end of the
string.

Then we allocate one more byte for the `chars` of the `erow`, and use
`memmove()` to make room for the new character. We increment the `size` of the
`chars` array, and then actually assign the character to its position in the
array. Finally, we call `editorUpdateRow()` so that the `render` and `rsize`
fields get updated with the new row content.

Now we'll create a new section called `/*** editor operations ***/`. This
section will contain functions that we'll call from `editorProcessKeypress()`
when we're mapping keypresses to various text editing operations. We'll add a
function to this section called `editorInsertChar()` which will take a
character and use `editorRowInsertChar()` to insert that character into the
position that the cursor is at.

{{editor-insert-char}}

If `E.cy == E.numrows`, then the cursor is on the tilde line after the end of
the file, so we need to append a new row to the file before inserting a
character there. After inserting a character, we move the cursor forward so
that the next character the user inserts will go after the character just
inserted.

Let's call `editorInsertChar()` in the `default` case of the `switch` statement
in `editorProcessKeypress()`. This will allow any keypress that isn't mapped to
another editor function to be inserted directly into the text being edited.

{{key-insert-char}}

## Prevent inserting special characters

Currently, if you press keys like backspace or the enter key, those characters
will be inserted directly into the text, which we certainly don't want. Let's
handle a bunch of these keys in `editorProcessKeypress()`, so that they don't
fall through to the `default` case of calling `editorInsertChar()`.

{{block-special-chars}}

Backspace doesn't have a human-readable backslash-escape representation in C
(unlike `\n`, `\r`, and so on), so we make it part of the `editorKey` enum and
assign it its ASCII value of `127` (which is `1111111` in binary, the highest
value a 7-bit ASCII character can have, interestingly).

In `editorProcessKeypress()`, the first new key we add to the `switch`
statement is `\r`, which is the enter key. For now we want to ignore it, but
obviously we'll be making it do something later, so we mark it with a `TODO`
comment.

We handle `BACKSPACE` and `DEL_KEY` in a similar way, marking them with a
`TODO`. We also handle the `Ctrl+H` key combination, which sends the control
code `8`, which is originally what the backspace character would send, back in
the day. If you look at the [ASCII table](http://www.asciitable.com/), you'll
see that ASCII code `8` is named `BS` for "backspace", and ASCII code `127` is
named `DEL` for "delete". But for whatever reason, in modern computers the
backspace key is mapped to `127` and the delete key is mapped to the escape
sequence `<esc>[3~`, as we saw at the end of
[chapter 3](03.rawInputAndOutput.html).

Lastly, we handle `Ctrl+L` and the `Escape` key by not doing anything when
those keys are pressed. `Ctrl+L` is traditionally used to refresh the screen in
terminal programs. In our text editor, the screen refreshes after any keypress,
so we don't have to do anything else to implement that feature. We ignore the
`Escape` key because there are many key escape sequences that we aren't
handling (such as the `F1`, `F2`, ..., `F12` keys), and the way we wrote
`editorReadKey()`, pressing those keys will be equivalent to pressing the
`Escape` key. We don't want the user to unwittingly insert the escape character
`27` into their text, so we ignore those keypresses.

## Save to disk

Now that we've finally made text editable, let's implement saving to disk.
First we'll write a function that converts our array of `erow` structs into a
single string that is ready to be written out to a file.

{{rows-to-string}}

First we add up the lengths of each row of text, adding `1` to each one for the
newline character we'll add to the end of each line. We save the total length
into `buflen`, to tell the caller how long the string is.

Then, after allocating the required memory, we loop through the rows, and
`memcpy()` the contents of each row to the end of the buffer, appending a
newline character after each row.

We return `buf`, expecting the caller to `free()` the memory.

Now we'll implement the `editorSave()` function, which will actually write the
string returned by `editorRowsToString()` to the file.

{{editor-save}}

`open()`, `O_RDWR`, and `O_CREAT` come from `<fcntl.h>`. `ftruncate()` and
`close()` come from `<unistd.h>`.

If it's a new file, then `E.filename` will be `NULL`, and we won't know where
to save the file, so we just `return` without doing anything for now. Later,
we'll figure out how to prompt the user for a filename to save it as.

Otherwise, we call `editorRowsToString()`, and `write()` the string to the path
in `E.filename`. We tell `open()` we want to creat a new file in case it
doesn't exist (`O_CREAT`), and we want to open it for reading and writing
(`O_RDWR`). Because we used the `O_CREAT` flag, we have to pass an extra
argument containing the mode (the permissions) the new file should have. `0644`
is the standard permissions you usually want for text files. It gives the owner
of the file permission to read and write the file, and everyone else only gets
permission to read the file.

`ftruncate()` sets the file's size to the specified length. If the file is
larger than that, it will cut off any data at the end of the file to make it
that length. If the file is shorter, it will add `0` bytes at the end to make
it that length.

The normal way to overwrite a file is to pass the `O_TRUNC` flag to `open()`,
which truncates the file completely, making it an empty file, before writing
the new data into it. By truncating the file ourselves to the same length as
the data we are planning to write into it, we are making the whole overwriting
operation a little bit safer in case the `ftruncate()` call succeeds but the
`write()` call fails. In that case, the file would still contain most of the
data it had before. But if the file was truncated completely by the `open()`
call and then the `write()` failed, you'd end up with all of your data lost.

More advanced editors will write to a new, temporary file, and then rename that
file to the actual file the user wants to overwrite, and they'll carefully
check for errors through the whole process.

Anyways, all we have to do now to let the user save is map a key to
`editorSave()`, so let's do it! We'll use `Ctrl+S` to save.

{{ctrl-s-save}}

You should be able to open a file in the editor, insert some characters, press
`Ctrl+S`, and confirm using `cat` or a text editor that the changes you made
were saved.

Let's add error handling to `editorSave()`.

{{editor-save-errors}}

`open()` and `ftruncate()` both return `-1` on error. We expect `write()` to
return the number of bytes we told it to write. Whether or not an error
occurred, we ensure that the file is closed and the memory that `buf` points to
is freed.

Let's use `editorSetStatusMessage()` to notify the user whether the save
succeeded or not. While we're at it, we'll add the `Ctrl+S` key binding to the
help message that's set in `main()`.

{{save-status-message}}

The above code doesn't actually compile, because we are trying to call
`editorSetStatusMessage()` before it is defined in the file. You can't do that
in C, because C was made to be a language that can be compiled in a [single
pass](https://en.wikipedia.org/wiki/One-pass_compiler), meaning it should be
possible to compile each part of a program without knowing what comes later in
the program.

When we call a function in C, the compiler needs to know the arguments and
return value of that function. We can tell the compiler this information about
`editorSetStatusMessage()` by declaring a function prototype for it near the
top of the file. This allows us to call the function before it is defined.
We'll add a new `/*** prototypes ***/` section and put the declaration under
it.

{{prototypes}}

## Dirty flag

{{dirty-variable}}

{{show-dirty}}

{{increment-dirty}}

{{reset-dirty}}

## Quit confirmation

{{quit-confirmation}}

## Simple backspace

{{row-del-char}}

{{editor-del-char}}

{{key-del-char}}

## Backspacing at the start of a line

{{del-row}}

{{row-append-string}}

{{del-char-row}}

## Deleting forward with the delete key

{{delete-forward}}

## Enter key

{{append-row-to-insert}}

{{use-insert-row}}

{{insert-newline}}

{{enter-key}}

## Save as...

{{editor-prompt}}

{{save-as}}

{{editor-prompt-escape}}

{{abort-save}}

{{prompt-backspace}}

