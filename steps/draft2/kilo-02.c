/* # Enable raw mode
 *
 * C programs on the command line read input from the keyboard line by line by
 * default. This is called *canonical mode*, or *cooked mode*. For a text
 * editor, we want what's called *raw mode*, so that we can respond to each key
 * the user presses immediately.
 *
 * Unfortunately there is no single switch we can flip to turn on raw mode.
 * Instead, it involves flipping several esoteric bits, some of which don't
 * even apply to the software terminals we use today and are there only for
 * historical reasons.
 *
 * The following code has been copied and pasted around for at least 20 years.
 * You can look at it as a magic incantation that you don't have to understand.
 * But I say you still have to type it in.
 */

#include <termios.h>
#include <unistd.h>

void enableRawMode() {
  struct termios raw;

  tcgetattr(STDIN_FILENO, &raw);

  raw.c_iflag &= ~(BRKINT | ICRNL | INPCK | ISTRIP | IXON);
  raw.c_oflag &= ~(OPOST);
  raw.c_cflag |= (CS8);
  raw.c_lflag &= ~(ECHO | ICANON | IEXTEN | ISIG);
  raw.c_cc[VMIN] = 0;
  raw.c_cc[VTIME] = 1;

  tcsetattr(STDIN_FILENO, TCSAFLUSH, &raw);
}

int main() {
  enableRawMode();

  return 0;
}

/* The `<termios.h>` header provides `tcgetattr()` to read a terminal's
 * attributes into a `termios` struct, and `tcsetattr()` to apply the
 * attributes in a `termios` struct to the terminal. So we get the terminal's
 * attributes, turn off a bunch of flags, and pass the modified struct to
 * `tcsetattr()` which applies the changes, and we are then in raw mode.
 *
 * However, when our program exits, it stays in raw mode. So when you run the
 * program, you may find that you aren't able to interact with your shell
 * properly. (Some shells may reset at least some of the attributes.) One of
 * the flags we turned off was `ECHO`, which means the keys you type won't be
 * printed back to you on the terminal. To fix this, you can always type
 * `reset` and press enter to reset your terminal back to normal. Of course,
 * you could also restart your terminal emulator entirely.
 *
 * We will have our program disable raw mode before it exits in the next step.
 * But first, I will attempt to explain each flag or constant in the above
 * code.
 *
 * * `STDIN_FILENO` comes from `<unistd.h>`. (All the other constants come from
 *   `<termios.h>`.) It is the file descriptor for the standard input, which
 *   should be the terminal.
 * * `BRKINT` is turned off so that break conditions are ignored and are read
 *   as a single null byte. This doesn't really apply to emulated terminals.
 * * `ICRNL` is turned off so that CR's (carriage returns) are not translated
 *   into NL's (newlines).
 * * `INPCK` is turned off to disable input parity checking, which also doesn't
 *   really apply to emulated terminals.
 * * `ISTRIP` is turned off so that input characters aren't stripped to 7 bits,
 *   and instead retain all 8 bits.
 * * `IXON` is turned off to disable <Ctrl-S> and <Ctrl-Q> pausing and
 *   restarting terminal output.
 * * `OPOST` is turned off to disable all post processing of output, such as
 *   mapping NL's to CR-NL's, expanding tabs to spaces, discarding <Ctrl-D>'s,
 *   translating lowercase to uppercase, etc. We just want the raw output.
 * * `CS8` is turned *on* to specify that the terminal transmits and receives
 *   8-bit bytes, as opposed to bytes that are 5, 6, or 7 bits in size.
 * * `ECHO` is turned off so that the characters you type don't automatically
 *   get printed in the terminal output.
 * * `ICANON` is turned off to allow you to read input byte by byte as it comes
 *   in from the keyboard, rather than reading input line by line.
 * * `IEXTEN` is turned off to disable extended features related to `ICANON`
 *   mode.
 * * `ISIG` is turned off to disable interrupts being generated by <Ctrl-C> or
 *   <Ctrl-Z>.
 * * The `VMIN` field contains the minimum bytes needed to satisfy a `read()`
 *   call. We set it to `0` which causes bytes to be read one at a time, and
 *   causes `read()` to return `0` if the read times out.
 * * The `VTIME` field specifies how much time `read()` should wait before
 *   timing out and returning `0` when it doesn't get any input. The value is
 *   in tenths of a second, so we are able to poll for keyboard input every 0.1
 *   second.
 * * `TCSAFLUSH` tells `tcsetattr()` to discard any input that has been
 *   received but not read, as it applies the changes to the terminal.
 *
 * Well, that was a bit rough. The tutorial will get a lot smoother from now
 * on, now that we've got that over with.
 */

